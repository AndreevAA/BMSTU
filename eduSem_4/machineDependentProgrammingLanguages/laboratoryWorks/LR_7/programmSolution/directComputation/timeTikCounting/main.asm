.model tiny
CODE SEGMENT
    ASSUME CS:CODE, DS:CODE
    ORG 100h ; отступ от начала параграфа на 256 байт
    
    ; jmp отличается от call при вызове резидентной подпрограммы тем, что jmp требует метку, а call - ret
    
main:	
	jmp init ; go to init func
	old          DD 0; то что переменные после init норм. Доступ всё равно есть
	timer        DB 0
	speed 		 DB 00h

my_08h proc; резидентная часть проги
	pushf; пушь флагов в стек (имитируют прерывания)
	
	call cs:old; вызов старого обработчика
	
	; нельзя пушить до call cs:old потому что запушишь дважды, тк при вызове ты тоже пушишь регистры
	
	push ax; пушим все нужные регистры в стек
	push dx
	push ds
	push es
	; пушим всё в стек для того чтобы по завершении обработчика прерывания все регистры должны вернуться в своё первоначальное состояние
	xor ax, ax
    mov al, ds:timer; 
    inc al
    mov ds:timer, al

    cmp ds:timer, 18
    jnz finish; если таймер != 18, то завершаем обработчик(он потом вызовится снова)

	newline: ;переход на новую строку каждую секунду
		mov ah, 2
		mov dl, 10
		int 21h
		mov dl, 13
		int 21h

    xor al, al
    mov ds:timer, al

    cmp ds:speed, 0
    jnz set_speed;  если скорость != 0, то мы ее уменьшаем, тк прыгаем от быстрой скорости к маленькой

    mov al, 31
    mov ds:speed, al; если скорость == 0, то делаем ее максимальной(31)

    set_speed:
    mov al, ds:speed
    dec al
    mov ds:speed, al

    mov al, 0F3h; команда автоповтора ввода символ(двуступенчатая)
    OUT 60h, al; ввод символа
    mov al, ds:speed; cкорось автоповтора в мс(тип на самом деле чем выше speed, тем ниже скорость повтора символов)
    OUT 60h, al; отвечает за то с какой скоростью символы будут появляться

    finish: ; очищаем стек от регистров
	pop es
	pop ds
	pop dx
	pop ax
	
	iret; используется для выхода из обработчика прерывания, восстанавливает флаги и IP
my_08h endp

init: ; не резидентная часть проги
    mov ax, 3508h ; al - номер нужного прерывания 08 - это таймер и срабатывает 18 раз с секунду bx - смещение dx - сегментеная часть
	int 21h;  внешне ничего не происходит в bx и es запишется адрес обработчика
	mov word ptr old,  bx ;засовывает в первые 2 байта переменной old bx(тип первая часть обработчика) 
	mov word ptr old + 2,  es; засовывает во вторые 2 байта переменной old es(тип вторая часть обработчика)
	
	; т.е. сейчас мы в old храним старый обработчик 08h до изменения в след строках кода
	
	mov ax,  2508h ;   говорит что каждый раз когда вызывается номер обработчика в al, то будет вместо этого обработчика вызываться указанная процедура
	mov dx, offset my_08h ; засовывает в ds:dx адрес какой-то процедуры
	int 21h ; т.е. теперь при вызове 08h будет вызываться my_08h
	
	mov ax, 3100h; завершает прогу с сохранением резидентной части в оперативе (31 - команда, а 00 - код завершения как в сях)
	mov dx, 30h; должны в dx загрузит сколько памяти мы загрузим в оперативку(слишком много параграфов и это стоит изменить. Глянуть у артема)
	int 21h; 
	

CODE ends
end main
